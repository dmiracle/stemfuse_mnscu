<p>Module: Graph Theory – 1 Credit / 15 hours</p>
<p>Competency: Mathematical Reasoning of Data </p>
<p>Author: Jack Pope </p>


<p>Instructor overview &amp; objective</p>
<p>This course module is about Graph Theory. </p>

<p>Given that this module is to be worth 1 credit, or 15 hours of coursework, the instructor should prepare three to five subtopic discussions. These should account for at least 5 hours of instructional material and might be in the form of lecture notes or lecture videos. The additional hours should be comprised of student labs or assignments.  </p>

<p>Traditionally, a course in Information Theory takes a theoretical approach, on paper. However, the field of Data Science is an empirical endeavor that programmatically emphasizes empirical evidence. </p>

<p>Axioms which we accept as true are what support logical proof. Evidence (data) supports empirical proof, certainty based on a measurement and its statistical significance. A weakness of logical proof occurs when erroneous accepted “facts” support an axiom. A weakness of the empirical proof occurs when the data sample does not represent a population.</p>

<p>To accommodate our purposes, we will use the Python programming language. The choice of programming language is ultimately left to the instructor.</p>


























<p>Schedule </p>
<p>UnitTopic</p>
<p>=========================================</p>
<p>1Overview</p>

<p>2Graph quantification and comparison</p>
<p>Exercise</p>

<p>3Graph as adjacency matrix </p>
<p>Exercise</p>

<p>4Graph as adjacency list </p>
<p>Exercise</p>

<p>5Graph traversal</p>
<p>Exercise</p>

<p>6Shortest path problems</p>
<p>Exercise</p>
<p>Traveling salesman problem</p>





























<p>Overview</p>
<p>A graph data structure is a collection of distinct vertices (nodes), connected by lines referred to as edges or arcs. Each vertex may be associated with a label or ID, and it may have a numeric value representing connecting edges.</p>

<p>The representation of each vertex and edge depends on the data structure employed. In object oriented programming there can be a Vertex class that contains a list of neighboring vertices and associated edges. An understanding of linked lists is prerequisite to formulating graphs as such. </p>

<p>More formally, a graph G can be described as a set of a sets of vertices V and a set of edges E. We can denote a graph G(V, E) such that V = V(G) and E = E(G). </p>

<p>When there is an edge e1 that connects two vertices v1 and v2, we say vertices v1 and v2 are “adjacent or neighbors.”  That is e1 represents the pair v1 and v2, or e1 = {v1, v2}. The term “endpoints” may thus refer to v1 and v2.</p>

<p>Graphs can also be represented by adjacency matrices and adjacency lists. These data structures can, in turn, be made of parallel lists or arrays or hash tables.</p>

<p>Properties of graphs in general:</p>
<ul>
<li><p>Edge – Connects a distinct pair of vertices.</p></li>
<li><p>Subgraph – A graph may exist within a graph. Given G = G(V, E), it may be denoted as H = H(V', E').</p></li>
<li><p>Digraph – A directed graph, wherein edges enforce direction of traversal. </p></li>
<li><p>Connected graph: Defined by a path between any two vertices.</p></li>
<li><p>Strongly connected – When a digraph has a path from every vertex to every other vertex.</p></li>
<li><p>Weighted graph – the edges have numeric values in terms of weight, cost, distance, .... </p>
<p> </p></li>
<li><p>Degree of vertex – The number of edges incident to a vertex. Ex: deg(v1) = 2</p></li>
<li><p>In-degrees and out-degrees – Pertain to the degrees in a digraph.</p></li>
<li><p>Isolated vertex – has no degree of incidence. </p></li>
<li><p>Regular graph – when every vertex has the same degree.</p></li>
<li><p>Path – A sequence of vertices from an origin vertex to a destination vertex. </p></li>
<li><p>Distance – Sum of the values for all intermediate edges of a path. </p></li>
<li><p>Cyclic graph – When a path within a graph returns to a vertex within, a cycle exists.</p></li>
<li><p>Acyclic graph – When no cycles exist within a graph.</p></li>
<li><p>Finite path – Any pair of vertices is connected by exactly two end points.</p></li>
<li><p>Infinite path – One vertex originates paths having more than one distinct end point. (Like a ray)</p></li>
<li><p>Finite graph – Graph of finite paths and no vertex is in more than one path.  </p></li>
<li><p>Locally finite – Subgraph that if finite.</p></li>
<li><p>Infinite graph – Graph of infinite paths.</p></li>
<li><p>Multigraph – When parallel or multiple edges connect the same vertex pairs if a graph.</p></li>
<li><p>Euler graph (path) – A path through a finite graph that traverses every edge exactly once. </p>
<p>  </p></li>
<li><p>Eulerian circuit – Euler path that ends and begins at the same vertex.</p></li>
<li><p>Loops – When an edge connects to a vertice to itself for self reference. Multiple loops on a single vertex allows it to be multigraph. </p></li>
<li><p>Sparse graph – Most vertices of the graph are not connected.</p>
<p>  </p></li>
<li><p>Dense graph – Most vertices of the graph are connected. </p></li>
</ul>

<p>Example of a connected and undirected graph:</p>
<p><img src=".//Pictures/100002010000032000000258C12A946F6AE91BDB.png" style="width:3.748in;height:2.811in" /></p>











<p>Undirected graphs can be:</p>
<ul>
<li>Connected </li>
<li>Complete </li>
<li><p>Disconnected</p></li>
</ul>
<p>Properties of a connected graph:</p>
<ul>
<li>Path exits between every pair of vertices.</li>
<li>Complete – If it has an edge between every distinct vertex pair.</li>
<li>Directed and complete – If each vertex pair has two directed edges.</li>
</ul>

<p><img src=".//Pictures/10000201000002630000017E15A39C4C736BEB4A.png" style="width:3.0902in;height:1.9319in" />Graph that is a connected simple path from vertex 0 to vertex 7:</p>

<p> </p>








<p><img src=".//Pictures/10000201000003200000025806584E62A2017D1C.png" style="width:3.0291in;height:2.2717in" />Graph that is complete:</p>












<p><img src=".//Pictures/10000201000001F4000001F4B29596B532D30046.png" style="width:2.6173in;height:2.6173in" />Graph that is disconnected and exhibits a simple cycle:</p>













<p>Adjacency: Two vertices, such as v3 and v4 above, are adjacent given that there is an undirected edge between them. This is equivalent to parallel directed edges, such that v3 → v4 and v3 ← v4. If the edge is directed only such that v3 → v4, then v4 is adjacent to v3 and v4 is not adjacent to v3.</p>







<p>Graph construction</p>
<p>One way to construct a graph:</p>
<ul>
<li><p>Make a class Vertex with attributes:</p>
<ul>
<li>label</li>
<li>degrees</li>
<li>adjacent neighbor list and associated edge weights</li>
<li>Possible counter for traversals or “visits”</li>
</ul></li>
<li>Use a list data structure to contain the Vertex objects. Possibly define a stack or queue. A hash table may be used.</li>
</ul>

<p>In pseudo code, a Vertex class of a simple graph having implied edges:</p>

<p>class Vertex:</p>
<p>   Vertex[] neighbor</p>
<p>   int[] distance2neighbor </p>
<p>                            int degrees = 0</p>
<p> </p>
<p>   Vertex(Vertex adjacentNeighbor, int distance):</p>
<p>      degrees = degrees + 1</p>
<p>      neighbor[degrees] = adjacentNeighbor</p>
<p>                               distance2neighbor[degrees] = distance</p>

<p>Conversely, an Edge class can be defined to have Vertex class attributes. </p>

<p>In Python we can have:</p>

<p>class Vertex:</p>
<p>   def __init__(self, val ):</p>
<p>       self.val = val</p>
<p>       self.edges = []</p>

<p>class Graph:</p>
<p>   def __init__(self, vertices=[] ):</p>
<p>       self.vertices = vertices</p>

<p>   def add_vertex(self, val ):</p>
<p>       new_vertex = Vertex(val )</p>
<p>       self.vertices.append(new_vertex )</p>

<p>   def add_edge(self, vertex1, vertex2 ):</p>
<p>       vertex1.edges.append(vertex2)</p>
<p>       vertex2.edges.append(vertex1)</p>






<p>Exercise</p>
<p>1. Write a Python program to build a simple connected graph. Populate your graph from data, either hard coded into your program or by file I/O. Run your program to display your graph as standard output. (Optionally, use the Networkx Python library for more visual appeal. See <a href="https://networkx.github.io/">https://networkx.github.io/</a> )</p>

<p>2. Write a function in Python to verify that a graph is regular.</p>

<p>Submit your code and your tested output.</p>

<p>Graph quantification and comparison</p>
<p>Quantification of graphs:</p>
<ul>
<li>Total degrees in a graph: 2 x edges</li>
<li><p>Density of graph of n vertices: 2 * edgeCount / n * (n - 1)</p>
<ul>
<li>Maximum density is 1, or 100%. </li>
<li>Minimum density is 0 (isolated graph).</li>
</ul></li>
<li>Number of edges in a graph of n vertices:</li>
</ul>
<ul>
<li>Complete directed graph: n - 1</li>
<li>Complete undirected graph: n * (n - 1) / 2</li>
<li>Directed graph: n * (n – 1)</li>
</ul>
<ul>
<li>Edge weight: may be assigned or computed, as below</li>
<li>Distance (see shortest path discussion below)</li>
</ul>

<p>Edge weight:</p>
<p>A weighted graph gives values to its edges, such as weight, cost, time, or distance. This is unlike an unweighted graph that represents relationships simply as true or false, or as 0 or 1. </p>
<p> </p>
<p>It may be the case that weights must be derived by your program. One method to compute distance is to assign Cartesian (x, y) coordinates to each vertex and then to compute the sum of distances between each vertex from the origin and the destination vertex. Between any two vertices in an XY plane, the distance, or Euclidean distance is:</p>

<p>( (x1 - x2)<sup>2</sup> + (y1 - y2)<sup>2</sup> )<sup>1/2</sup></p>

<p>The advantage of having weights based on Euclidean distance is that it affords representing graphs beyond two or even three dimensions, such that the distance between any vertex pairs can be determined as:</p>

<p>( (x1 - x2)<sup>2</sup> + (y1 - y2)<sup>2</sup> + … + (z1 - z2)<sup>2</sup> )<sup>1/2</sup> </p>

<p>Such coordinates can be useful for highly dimensional factor analytics.</p>







<p>Graph density example:</p>
<p>Using Python, density may be computed as follows. Suppose we have a graph represent be the following adjacency list G (more about adjacency lists below):</p>

<p>G = { </p>
<p>  “a” : [“b”, “d”],</p>
<p>  “b” : [“a”, “b”, “c”, “d”],</p>
<p>  “c” : [“a”, “b”],</p>
<p>  “d” : [“a”, “b”]</p>
<p>}</p>

<p>Populate a data structure:</p>

<p>edges = []</p>
<p>for vertex in G:</p>
<p>  for neighbor in G[vertex]:</p>
<p>     if {neighbor, vertex} not in edges:</p>
<p>        edges.append({vertex, neighbor})</p>

<p>A density algorithm:</p>

<p>def density(G):</p>
<p> n = len(G.keys())</p>
<p> edgeCount = len(G.edges())</p>
<p> return 2.0 * edgeCount / (n * (n - 1))</p>

<p>Comparing of graphs:</p>
<ul>
<li>Equality: same structure, data and order; equal objects are identical</li>
<li>Identity: same data and order; maybe different structure (identical may be equal)</li>
<li>Isomorphism: same number of vertices, edges and degrees at each level (data irrelevant) </li>
</ul>

<p>Two graphs are isomorphic if they can be mapped one-to-one to each other and preserve the relationships between vertices. These are essentially the same graphs though they may look different.</p>

<p>Applications of graph comparison include analysis of fingerprints and social networks.  </p>

<p>Incidentally, a connected undirected graph can be equivalent to a directed graph if each of the vertex pairs of the former connect by two directed edges, one going in each direction between nodes.</p>

<p>Exercise</p>
<p>Write a Python program that generates two undirected graphs G1 and G2, each with vertices A to Z, and each with randomly connected vertices (no more than one connection to a pair of vertices). The connection weights should be random integers from 1 to 10. Determine if G1 and G2 are equal, identical and isomorphic.</p>

<p>Submit your code and your tested output.</p>


<p>Graph as adjacency matrix </p>
<p>We can construct an adjacency matrix to see which vertices are adjacent. Intersections in the matrix may be assigned 0 or 1 (true of false) for unweighted graphs or have other values if weighted. </p>

<p>An adjacency matrix can be constructed using a multi-dimensional array or parallel lists. An algorithms with a nested loop allows iteration over all possible vertex pairs. </p>

<p>The following pseudo code counts the number of edges for an undirected adjacent matrix:</p>

<p>for i 0 to n :</p>
<p>   for j 0 to m :</p>
<p>       if pair[i][j] != pair[j][i] :</p>
<p>           count = count + 1</p>

<p>Since the adjacency matrix is symmetric about the diagonal, neither the diagonal nor values above the diagonal are counted. Hence, for an undirected adjacent matrix, </p>

<p>total number of possible edges = n * (n - 1) / 2 </p>

<p><img src=".//Pictures/1000020100000320000002589B35CAA07A93D0FC.png" style="width:4.2709in;height:3.2028in" />For a directed graph, entries are only made in the adjacency matrix if direction to a vertex exists. For example, consider the following adjacency matrix for the directed graph on the right. As you can see, the pair (1, 2) has and entry of 0 while the pair (2, 1) has an entry of 1. Because of the direction from vertex 1 to vertex 2, vertex 2 is adjacent to vertex 1 and vertex 1 is not adjacent to vertex 2.</p>


<p><embed src=".//Pictures/2000052C0000226C0000129C31B97D6122DB613E.svm" style="width:3.2457in;height:1.7547in" /></p>










<p>The total possible edges for this graph is: 8 * (8 – 1) / 2 == 56 / 2 == 28. However, the directional edges indicate just 10 neighbors. Stated differently, the connections of a directed graph have a head and a tail, whereby only the heads are counted.</p>

<p>Exercise</p>
<p>1. Write a function in Python to generate an adjacency matrix from a list of of vertex pairs.</p>
<p>2. Write a function in Python to determine if a graph is directed or undirected. </p>

<p>Submit your code and your tested output.</p>




<p>Graph as adjacency list</p>
<p>The adjacency list is an alternative way to represent adjacency matrices. This is a list consisting only of those vertex pairs that are “adjacent.” Because the adjacency list excludes the data of non-adjacent vertices, it requires fewer system resources, such as memory and disk space, than the adjacency matrix. </p>

<p>An adjacency list is recommended for representing large sparse graphs. </p>

<p>The implementation of an adjacency list can be via list, trees, or hash table.</p>


<p>An adjacency list can be represented as follows:</p>

<p>G = [v5:v1, v3; v6:v1, v3, v5; … vN{}]</p>

<p>… showing each vertex followed by a lists of its neighbors.</p>

<p>Alternatively:</p>

<p>G = [v5:1, 3; v6:1, 3, 5; … vN{}]</p>

<p>… where each vertex is followed by the index of its neighbors in the adjacency table, or G[i:i,j]</p>
<p>   </p>
<p>As a hash table the adjacency list can have a key associated with a list of neighbors:</p>

<p>G[v5] = {v1,v3,...</p>

<p>In Python such an adjacency list can look as follows:</p>

<p>graph = {</p>
<p> 5: [1, 3],</p>
<p> 6: [1, 3, 5]</p>
<p>}</p>

<p>If the graph is weighted, perhaps with percentiles, the adjacency list can be denoted as:</p>

<p>G = { (5, 1):0.5, (5, 3):0.8, (6, 1):0.2, (6, 3):0.4, (6, 5): 0.9 }</p>

<p>Or, in Python as:</p>

<p>weight = {</p>
<p> (5, 1): 0.5,</p>
<p> (5, 3): 0.8,</p>
<p> (6, 1): 0.2,</p>
<p> (6, 3): 0.4,</p>
<p> (6, 5): 0.9</p>
<p>}</p>



<p>For example, reading an adjacency list from file graphdata.txt,</p>

<p>graphdata.txt:</p>
<p>0,1,3</p>
<p>0,2,4</p>
<p>2,5,7</p>
<p>3,4,6</p>
<p>4,2,5</p>

<p>… now draw the graph (in Python with Networkx library):</p>

<p>import sys</p>
<p><img src=".//Pictures/100002010000032000000258AFD0C373CDBABDAC.png" style="width:4.0937in;height:3.0701in" />import matplotlib.pyplot as plt</p>
<p>import networkx as nx</p>

<p>options = {</p>
<p>   'node_color': 'lightblue',</p>
<p>   'node_size': 900,</p>
<p>   'width': 3,</p>
<p>   'arrowstyle': '-|&gt;',</p>
<p>   'arrowsize': 12,</p>
<p>   'font_size': 15</p>
<p>}</p>

<p>the_file = "graphdata.txt"</p>
<p>G = nx.DiGraph()</p>

<p>with open(the_file) as f:</p>
<p> for line in f:</p>
<p>   a, b, w = map(int, line.strip().split(','))</p>
<p>   G.add_edge(a, b, weight = w)</p>

<p>pos = nx.spring_layout(G,scale=1)</p>
<p>nx.draw(G,pos,font_size=8)</p>
<p>nx.draw_networkx(G, pos, arrows=True, **options)</p>
<p>plt.show()</p>

<p>Exercise</p>
<p>Write a function graph_density that determines if a graph is dense or sparse according to a file containing an adjacency list. If the graph is sparse, the function calls another function, adjacency_matrix, to generate an adjacency matrix. </p>

<p>Your graph_density function should additionally read a file containing an adjacency matrix. If the adjacency matrix is dense, your function calls another function, adjacency_list, to generate an adjacency list.<br />
</p>
<p>Provide your functions and your test results. </p>


<p>Graph traversal</p>
<ul>
<li>Traversal begins with any vertex – the “origin” vertex</li>
<li>Visiting a vertex in a graph does not entail processing its data.</li>
<li>Only vertices that are connected can be traversed. </li>
<li>Methods include Depth First Search and Breadth First Search</li>
</ul>

<p>Depth first search and breadth first search methods:</p>
<ul>
<li>Find all neighbors of a vertex.</li>
<li>Find all paths between an origin and destination vertex.</li>
</ul>

<p>Depth first search (DFS): Visit a neighbor of the origin, a neighbor of the neighbor, and so on, advancing as far as possible from the origin. Then go back to the first neighbor and repeat this procedure from there, traversing to unvisited neighbors. Sometimes a stack data structure is used to ensure that each path of neighbors is traversed in reverse to get back to the origin. DFS is also used for a topological sort (see below).</p>


<p>In Python, we have the following depth first and breadth first search functions, as popularized by Guido van Rossum, the creator of Python (<a href="https://www.python.org/doc/essays/graphs.html">https://www.python.org/doc/essays/graphs.html</a> … link is now defunct). </p>

<p>A recursive DFS algorithm:</p>

<p>def dfs(graph, start, path=[]):</p>
<p> path += [start]</p>

<p> for vertex in graph[start]:</p>
<p>   if not vertex in path:</p>
<p>     path = dfs(graph, vertex, path)</p>

<p> return path</p>

<p>An iterative DFS algorithm:</p>

<p>def dfs(graph, start, path=[]):</p>
<p> front = [start]</p>

<p> while front:</p>
<p>   vertex = front.pop(0)</p>
<p>    </p>
<p>   if vertex not in path:# versus bfs... if not vertex in path</p>
<p>     path += [vertex]</p>
<p>     front += graph[vertex]</p>
<p>  </p>
<p> return path</p>



<p>The aforementioned algorithms can be tested on a graph of the following adjacency list form:</p>

<p>graph = {</p>
<p> 'A': ['B', 'C'], </p>
<p> 'B': ['D', 'E'],</p>
<p> 'C': ['E'], </p>
<p> 'D': ['F'], </p>
<p> 'E': ['F'],</p>
<p> 'F': ['G', 'D'],</p>
<p> 'G': []</p>
<p>}</p>

<p>Breadth first search (BFS): Visit each neighbor, then each neighbor's neighbor, and so on. Sometimes a queue data structure is used to ensure that no neighbor is visited more than once. DFS can additionally yield the minimum edge accumulation in a path (shortest path). </p>

<p>In Python:</p>

<p>def bfs(graph, start, path=[]):</p>
<p> front = [start]</p>

<p> while front:</p>
<p>   vertex = front.pop(0)</p>
<p>   </p>
<p>   if not vertex in path:# versus iterative dfs... if vertex not in path</p>
<p>     path += [vertex]</p>
<p>     front += graph[vertex]</p>
<p> </p>
<p> return path</p>

<p>Note how the above algorithm is almost identical to the iterative DFS function above.</p>


















<p>Shortest path problems</p>
<p>Graph traversal methods for finding the shortest path entail adding up the connecting edges in the chain of neighbors between the origin vertex and destination vertex. The solution to an unweighted shortest path problem will be the path having minimum number of edges.</p>

<p>Recall that edges can be weighted. That is, associated values vary over some range, such as distance, correlation, or time. A path can represent a sum of decisions and have an associated cost. A solution will have a “total distance” or “total cost.”</p>

<p>total vertices in shortest path &lt; n – 1</p>

<p>Some shortest path methods:  </p>
<ul>
<li>Dijkstra's algorithm</li>
<li>All pairs (Floyd-Warshall) algorithm</li>
<li>Topological ordering</li>
<li>Minimum spanning tree</li>
</ul>

<p>Dijkstra:</p>
<ul>
<li>Set origin distance to 0. </li>
<li>Set all vertex distances to max possible distance.</li>
<li>Select unvisited vertex V1 having minimum distance from origin V0. (some use a queue)</li>
<li>Select unvisited vertex V2 having minimum distance from vertex V1.</li>
<li>… Repeat until at destination vertex.</li>
</ul>

<p>The Dijkstra algorithm exhaustively finds the shortest path between the origin vertex and every other of the graph's vertices. </p>

<p>All pairs:</p>
<ul>
<li>Set origin distance to 0. </li>
<li>Set all vertex distances to max possible distance.</li>
<li>For every vertex, accumulate the minimum distance to every neighbor.</li>
<li>Given distance[i][j] == 0 where i and j represent the origin, the destination distance depends on specified i,j </li>
</ul>

<p>The all-pairs (Floyd-Warshall) method computes the shortest path between all vertex pairs. The method is relatively straight forward:</p>

<p>for (int i = 0; i &lt; n; i++) {</p>
<p>   for (int j = 0; j &lt; n; j++) {</p>
<p>       for (int k = 0; k &lt; n; k++) {</p>
<p>           distance[i][k] = min(distance[i][k], distance[i][j] + distance[j][k]);</p>
<p>       }</p>
<p>   }</p>
<p>}</p>




<p>Given a weighted adjacency matrix, using a dictionary of form... </p>
<p>g[1,1] = 2</p>
<p>g[1,3] = 4</p>
<p>g[1,5] = 6</p>

<p>In Python we can have:</p>
<p> </p>
<p>def all_pairs(g, n):</p>
<p> dist = {0: g}</p>

<p> for i in range(1, n + 1):</p>
<p>   dist[i] = {}</p>
<p>        </p>
<p>   for j in range(1, n + 1):</p>
<p>     for k in range(1, n + 1):</p>
<p>       dist[i][j, k] = min(dist[i - 1][j, k], dist[i - 1][i, j] + dist[i - 1][i, k])</p>

<p> return dist[n]</p>

<p>Topological sort:</p>
<p>For modeling systems wherein there are subsets of required sequence or dependencies, we can use a topological sort. In the context of a directed graph, the vertices of subgraphs or paths are queried with respect to edge weights. Another term for this is “precedence graph.” </p>

<p>Formally, a topological sort of a directed acyclic graph G = (V, E) is a linear ordering of vertices such that if an edge (u, v) exists in G, then u is listed before v in the linear sequence.</p>

<p>For the shortest path problem of a weighted acyclic graph G with vertices V, the topological sort can be used as follows:</p>
<p> </p>
<p>Initialize collections:</p>
<p>for i 1 to n of G:</p>
<p> dist[i] = maxint</p>

<p>Initialize the origin vertex:</p>
<p>dist[Vo] = 0 … the origin vertex</p>

<p>Topologically sort all vertices:</p>
<p>for every vertex V[i]:</p>
<p> for every vertex V[j]:</p>
<p>   if(V[j] is adjacent to V[i]):</p>
<p>     if(dist[j] &gt; dist[i] + weight(i, j)):</p>
<p>         dist[j] = dist[i] + weight(i, j) </p>






<p>Minimum spanning tree:</p>
<p>A tree is an acyclic graph that is connected. When that tree connects all vertices in an undirected weighted graph at minimum distance, we have a minimum spanning tree (MST). </p>

<p>Formally, given an undirected weighted graph G = (V, E), an MST is the set T of edges in E that connect all vertices with a minimum total distance. These edges form a tree because each vertex has only one parent apart from the root vertex.</p>

<p>MST algorithm:</p>
<ol type="1">
<li>Rank the graph edges from least to most weight, storing the results in list ranked_edges.</li>
<li>Traverse ranked_edges, removing those that do not disconnect the graph.</li>
</ol>
<p>Or:</p>
<ol type="1">
<li>Rank the edges from most to least weight, storing the results in list ranked_edges.</li>
<li>Traverse ranked_edges, summing the weights of edges that do not create a cycle.</li>
</ol>

<p>Based on the second version of this algorithm, find the MST of a graph of vertices A, B, C, D, E, and F. </p>

<p>Edges:  B-D A-E D-F B-F C-E A-C A-F B-E B-C        </p>
<p>Weight:  2      4      5     6     7      8     8      9     9           </p>
<p>Add?  Yes  Yes   Yes  No  Yes   No Yes  No  No</p>

<p>Edges of MST:  B-D A-E D-F  C-E A-F   </p>
<p>Sum of edges:    2 + 4 + 5  + 7 + 8  == 26 </p>

<p>Exercises</p>
<p>For the following tasks, submit tested code and and related output.</p>

<p>Tasks:</p>
<p>1. Devise a function to determine if a graph is strictly a tree.  </p>

<p>2. Given any two random vertices in a connected graph, write a Python program to compare Dijkstra and MST approaches for computing the shortest path. See that you get the same results. How doe there processing times compare? </p>

<p>3. Write an algorithm to topologically sort a graph. Test your algorithm on graphs that contain a cycle and those that don't. Compare the run times and output of these two scenarios. What do you find most remarkable? </p>

<p>4. Euler theorized that the “Eulerian graph” exists if and only if each vertex has an even numbered degree. Write a Python program to prove Euler correct, or not.</p>









<p>Traveling salesman problem (summation of paths)</p>
<p>Consider a cyclic and connected graph that permits every node to be visited at least once. Such a graph is also called a “Hamiltonian circuit.” Unlike a Eulerian circuit, which must traverse each edge exactly once (and can repeat vertex visits), the Hamiltonian circuit must visit each vertex exactly once (and can re-traverse edges). </p>

<p>Like a Hamiltonian circuit, the traveling salesman problem entails a visit to locations. The challenge is to determine the path that minimizes total distance, for multiple locations. As the number of cities increases, there is a combinatorial explosion in the number of possible routes. </p>

<p>Total possible routes (Hamiltonian circuits) in a complete graph having n vertices:</p>

<p>H = (n – 1)! / 2</p>

<p>Solutions put forth in the programming communuity have included the following techniques:</p>
<ul>
<li>Brute force nearest neighbor assessment</li>
<li>Simulated annealing</li>
<li>Genetic algorithms</li>
<li>Minimum spanning trees</li>
<li>Neural networks</li>
<li>Implementation of constraints</li>
<li>Other exotic and sophisticated methods.</li>
</ul>

<p>A somewhat naïve approach using the nearest neighbor method:</p>
<ul>
<li>For every targeted vertex, compute the distance to each of the other targeted vertices</li>
<li>For each target vertex, sort the other targeted vertices by distance </li>
<li>Move to the nearest target vertice that has not been visited.</li>
<li>Repeat, until circuit is complete</li>
</ul>

<p>TSP makes for an interesting exploration of computation that might suit a distinct competency module in its own right. Look for working examples in the Big Data Analytics course module.</p>



<p>Additional Internet resources</p>
<p><a href="http://graphviz.org/gallery/">http://graphviz.org</a></p>
<p><a href="https://networkx.github.io/">https://networkx.github.io/</a></p>
<p><a href="https://www.python.org/doc/essays/graphs/">https://www.python.org/doc/essays/graphs/</a> </p>
<p><a href="http://mitpress.mit.edu/books/introduction-algorithms-third-edition">http://mitpress.mit.edu/books/introduction-algorithms-third-edition</a></p>
<p><a href="https://scipbook.readthedocs.io/en/latest/routing.html">https://scipbook.readthedocs.io/en/latest/routing.html</a></p>


